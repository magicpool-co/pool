package rvn

import (
	"bytes"
	"testing"
)

func TestGenerateCoinbase(t *testing.T) {
	tests := []struct {
		address        string
		amount         uint64
		height         uint64
		extraData      string
		defaultWitness string
		prefixP2PKH    []byte
		prefixP2SH     []byte
		coinbaseHex    []byte
		coinbaseHash   []byte
	}{
		{
			address:        "RFFABGPdXjRoqLxX36BxnPmTCSWTpZzq7C",
			amount:         500000000000,
			height:         1874596,
			extraData:      "/Beepool/",
			defaultWitness: "",
			prefixP2PKH:    mainnetPrefixP2PKH,
			prefixP2SH:     mainnetPrefixP2SH,
			coinbaseHex: []byte{
				0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0e, 0x03, 0xa4, 0x9a, 0x1c, 0x00, 0x2f,
				0x42, 0x65, 0x65, 0x70, 0x6f, 0x6f, 0x6c, 0x2f, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x88, 0x52,
				0x6a, 0x74, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x41, 0x6e, 0x56, 0x05, 0x75, 0xb8, 0xf4,
				0x5d, 0xf6, 0xf7, 0xaf, 0x74, 0x7c, 0x4d, 0x98, 0x92, 0x1e, 0xf5, 0xd9, 0xd1, 0x88, 0xac, 0x00,
				0x00, 0x00, 0x00,
			},
			coinbaseHash: []byte{
				0x29, 0xf1, 0x69, 0x6e, 0x5f, 0x52, 0x60, 0xf1, 0xe1, 0xda, 0xc7, 0x93, 0xad, 0x29, 0xdb, 0x8b,
				0x0a, 0xe9, 0x78, 0x9e, 0x08, 0xac, 0x6d, 0x72, 0x33, 0x24, 0xf4, 0xd7, 0xba, 0x35, 0x08, 0x58,
			},
		},
		{
			address:        "RFFABGPdXjRoqLxX36BxnPmTCSWTpZzq7C",
			amount:         500000831906,
			height:         1874415,
			extraData:      "/Beepool/",
			defaultWitness: "",
			prefixP2PKH:    mainnetPrefixP2PKH,
			prefixP2SH:     mainnetPrefixP2SH,
			coinbaseHex: []byte{
				0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0e, 0x03, 0xef, 0x99, 0x1c, 0x00, 0x2f,
				0x42, 0x65, 0x65, 0x70, 0x6f, 0x6f, 0x6c, 0x2f, 0xff, 0xff, 0xff, 0xff, 0x01, 0xa2, 0x39, 0x5f,
				0x6a, 0x74, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x41, 0x6e, 0x56, 0x05, 0x75, 0xb8, 0xf4,
				0x5d, 0xf6, 0xf7, 0xaf, 0x74, 0x7c, 0x4d, 0x98, 0x92, 0x1e, 0xf5, 0xd9, 0xd1, 0x88, 0xac, 0x00,
				0x00, 0x00, 0x00,
			},
			coinbaseHash: []byte{
				0xa0, 0x1a, 0x50, 0x11, 0xc3, 0xee, 0xbc, 0x4a, 0xe8, 0xed, 0xfe, 0x21, 0x26, 0xdb, 0xbe, 0x65,
				0xd6, 0x79, 0x22, 0xe3, 0x23, 0x67, 0xa7, 0xf5, 0x10, 0xdb, 0x20, 0xb5, 0xff, 0x07, 0xa4, 0x83,
			},
		},
	}

	for i, tt := range tests {
		coinbaseHex, coinbaseHash, err := GenerateCoinbase(tt.address, tt.amount, tt.height, tt.extraData,
			tt.defaultWitness, tt.prefixP2PKH)
		if err != nil {
			t.Errorf("failed on %d: GenerateCoinbase: %v", i, err)
		} else if bytes.Compare(coinbaseHex, tt.coinbaseHex) != 0 {
			t.Errorf("failed on %d: coinbase hex mismatch: have %x, want %x", i, coinbaseHex, tt.coinbaseHex)
		} else if bytes.Compare(coinbaseHash, tt.coinbaseHash) != 0 {
			t.Errorf("failed on %d: coinbase hash mismatch: have %x, want %x", i, coinbaseHash, tt.coinbaseHash)
		}
	}
}
